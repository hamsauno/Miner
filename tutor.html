<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<title>Калькулятор доходности майнинга</title>
<meta name="description" content="Удобный Telegram-калькулятор для расчета доходности ASIC-майнеров. Доход, прибыль, ROI, окупаемость — всё в одном месте.">
<style>
  html, body {
    overscroll-behavior-y: none; /* запрещает "отпружинивание" на iOS и Android */
    touch-action: pan-y; /* безопасно включает вертикальный и горизонтальный скролл */
  }
  /* Ensure no rounded corners */
  input, select {
    border-radius: 0 !important;
    -webkit-appearance: none; /* Remove default iOS styling */
    -moz-appearance: none; /* Remove default Firefox styling */
    appearance: none; /* Remove default styling */
  }
  /* Style for currency buttons */
  .currency-btn {
    border: none;
    padding: 0.5rem; /* Adjust padding as needed */
    margin: 0;
    font-size: 0.75rem; /* text-xs */
    font-weight: bold;
    transition: background-color 0.3s, color 0.3s;
    width: 50%; /* Make buttons take half the cell width */
    line-height: 1; /* Adjust line height if needed */
    height: 100%; /* Make buttons fill cell height */
  }
  .currency-btn.active {
    background-color: #E2E2E2;
    color: black;
  }
  .currency-btn.inactive {
    background-color: #2511A8;
    color: white;
  }
  .currency-btn:hover {
    filter: brightness(110%);
  }
  /* Remove spinner buttons from number inputs */
  input[type=number]::-webkit-inner-spin-button,
  input[type=number]::-webkit-outer-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  /* Стили для модального окна обучения */
  .tutorial-modal-overlay {
      display: none; /* Скрыто по умолчанию */
      position: fixed;
      z-index: 9998; /* Чуть ниже самого модального окна */
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.8); /* Затемняющий фон, можно сделать темнее */
      pointer-events: auto; /* Чтобы перехватывать клики */
  }

  .tutorial-modal {
      display: none; /* Скрыто по умолчанию */
      position: fixed;
      z-index: 10000; /* Выше оверлея и подсвеченного элемента */
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background-color: #1F2937; /* Темный фон для модалки (Tailwind gray-800) */
      color: #F3F4F6; /* Светлый текст (Tailwind gray-100) */
      padding: 15px; /* Уменьшенный padding */
      border: 1px solid #4B5563; /* Tailwind gray-600 */
      width: 80%; /* Уменьшенная ширина */
      max-width: 350px; /* Максимальная уменьшенная ширина */
      border-radius: 0; /* Убраны скругления */
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      text-align: center;
  }
  .tutorial-modal h3 {
      margin-top: 0;
      margin-bottom: 10px; /* Уменьшен отступ */
      font-size: 1.1rem; /* Уменьшен размер шрифта */
      font-weight: 600; /* font-semibold */
  }
  .tutorial-modal p {
      margin-bottom: 15px; /* Уменьшен отступ */
      font-size: 0.8rem; /* Уменьшен размер шрифта */
      line-height: 1.4;
  }
  .tutorial-modal button {
      padding: 8px 12px; /* Уменьшен padding кнопок */
      font-size: 0.8rem; /* Уменьшен размер шрифта кнопок */
      font-weight: 500; /* font-medium */
      cursor: pointer;
      border: none;
      border-radius: 0; /* Убраны скругления у кнопок */
      transition: background-color 0.2s;
  }
  .tutorial-modal-next-btn {
      background-color: #2563EB; /* Tailwind blue-600 */
      color: white;
  }
  .tutorial-modal-next-btn:hover {
      background-color: #1D4ED8; /* Tailwind blue-700 */
  }
  .tutorial-modal-skip-btn {
      background-color: #4B5563; /* Tailwind gray-600 */
      color: #F3F4F6; /* Tailwind gray-100 */
      margin-left: 8px; /* Уменьшен отступ */
  }
  .tutorial-modal-skip-btn:hover {
      background-color: #374151; /* Tailwind gray-700 */
  }

  /* Стиль для подсветки элемента */
  .tutorial-highlight {
      box-shadow: 0 0 0 3px #FBBF24, 0 0 15px 3px #FBBF24; /* Tailwind amber-400 */
      border-radius: 0 !important; /* Убраны скругления для подсветки */
      transition: box-shadow 0.3s ease-in-out;
      position: relative; /* Для позиционирования подсказки */
      z-index: 9999; /* Чтобы было над оверлеем, но под модальным окном */
      pointer-events: auto; /* Разрешаем взаимодействие с подсвеченным элементом */
  }

  /* Дополнительный стиль, чтобы заблокировать остальные элементы */
  body.tutorial-active > *:not(.tutorial-modal-overlay):not(.tutorial-modal):not(.tutorial-highlighted-ancestor) {
      pointer-events: none !important;
      /* filter: blur(2px); опционально для размытия фона */
  }
  /* Если подсвечиваемый элемент вложен, его родителям нужно разрешить события */
  .tutorial-highlighted-ancestor {
      pointer-events: auto !important;
  }
  #hashrateContainer select { /* Стиль для селекта хешрейта, если он создается */
    background-color: #E2E2E2;
    width: 100%;
    padding: 0.1rem 0.5rem; /* py-1 px-2 equivalent */
    border: 1px solid #9CA3AF; /* border-gray-400 */
    color: black;
    font-size: 0.875rem; /* text-sm */
    border-radius: 0 !important; /* Ensure no rounded corners */
    -webkit-appearance: menulist; /* Restore some default select appearance if needed */
    -moz-appearance: menulist;
    appearance: menulist;
  }

</style>

</head>
<body class="bg-black"> <div id="headerSection" class="w-full bg-[#000000] text-white shadow-xl p-5 mb-[3px]">
      <div class="form-content space-y-2">
         <div class="flex gap-3">
           <div class="w-1/2">
             <label for="algorithmSelect" class="block text-sm font-medium mb-1">Алгоритм</label>
             <select id="algorithmSelect"
               class="bg-[#E2E2E2] w-full px-2 py-1 border border-gray-400 text-black text-sm focus:outline-none focus:ring-2 focus:ring-yellow-400 rounded-none">
               <option value="SHA-256">SHA-256</option>
               <option value="Scrypt">SCRYPT</option>
             </select>
           </div>
           <div class="w-1/2">
             <label for="manufacturerSelect" class="block text-sm font-medium mb-1">Производитель</label>
             <select id="manufacturerSelect"
               class="bg-[#E2E2E2] w-full px-2 py-1 border border-gray-400 text-black text-sm focus:outline-none focus:ring-2 focus:ring-yellow-400 rounded-none">
               </select>
           </div>
         </div>

         <div>
           <label for="asicModel" class="block text-sm font-medium mb-1">Модель Оборудования</label>
           <select id="asicModel"
             class="bg-[#E2E2E2] w-full px-2 py-1 border border-gray-400 text-black text-sm focus:outline-none focus:ring-2 focus:ring-yellow-400 rounded-none">
             </select>
         </div>

         <div class="flex gap-3">
           <div class="w-1/2">
             <label class="block text-sm font-medium mb-1">Хэшрейт</label>
             <div id="hashrateContainer" class="bg-[#E2E2E2] px-2 py-1 text-sm text-black min-h-[28px] rounded-none flex items-center">
                <span id="hashrate"></span>&nbsp;<span id="edprice"></span>
             </div>
           </div>
           <div class="w-1/2">
             <label class="block text-sm font-medium mb-1">Потребление</label>
             <div id="powerContainer" class="bg-[#E2E2E2] px-2 py-1 text-sm text-black min-h-[28px] rounded-none flex items-center"> <span id="power"></span><span id="power_unit"></span> </div>
           </div>
         </div>

         <div class="flex gap-3">
           <div class="w-1/2">
             <label for="electricityCost" class="block text-sm font-medium mb-1">Стоимость <br> Электроэнергии</label>
             <div class="relative">
               <input
                 type="number"
                 id="electricityCost"
                 value="5"
                 inputmode="decimal"
                 step="any"
                 class="bg-[#E2E2E2] w-full px-2 py-1 pr-6 border border-gray-400 text-black text-sm focus:outline-none focus:ring-2 focus:ring-yellow-400 rounded-none">
               <span class="absolute right-2 top-1/2 -translate-y-1/2 text-black text-xs">₽</span>
             </div>
           </div>
           <div class="w-1/2">
             <label for="asicCost" class="block text-sm font-medium mb-1">Стоимость <br> Оборудования</label>
             <div class="relative">
               <input type="number" id="asicCost" inputmode="numeric"
                 class="bg-[#E2E2E2] w-full px-2 py-1 pr-6 border border-gray-400 text-black text-sm focus:outline-none focus:ring-2 focus:ring-yellow-400 rounded-none"
                 placeholder="Авто/Ручной ввод"> <span class="absolute right-2 top-1/2 -translate-y-1/2 text-black text-xs">₽</span>
             </div>
           </div>
         </div>

         <input type="hidden" id="btcPrice">
         <input type="hidden" id="usdtPrice">
         <input type="hidden" id="profitPerTH">
         <input type="hidden" id="ltcPrice">
         <input type="hidden" id="dogePrice">
         <input type="hidden" id="bellPrice">
         <input type="hidden" id="profitPerLTC">
         <input type="hidden" id="profitPerDOGE">
         <input type="hidden" id="profitPerBELL">
      </div>
      <div class="button-container pt-2">
        <button id="calculateBtn"
          class="w-full text-white font-bold text-base py-2 px-4 transition duration-300 hover:brightness-110 shadow-md rounded-none"
          style="background-color: #2511A8;">
          Рассчитать
        </button>
        <div id="notification" class="mt-2 p-2 text-center text-white bg-black hidden rounded-none">
          Расчёт произведён
        </div>
      </div>
   </div>

   <div id="resultsContainer" class="w-full bg-[#E2E2E2] text-sm space-y-4 shadow-md px-4 pb-4 pt-4 rounded-none">
     <div>

       <div id="progressBarContainer" class="w-full h-5 relative overflow-hidden border rounded-none" style="border-color: #2511A8;">
         <div id="dailyProfitBar" class="absolute top-0 left-0 h-full transition-all duration-500" style="background-color: #2511A8;"></div>
         <div id="dailyElectricityCostBar" class="absolute top-0 h-full transition-all duration-500" style="background-color: #CCCCCC;"></div>
       </div>
       <div class="mt-1 text-xs text-black flex justify-between">
         <div id="profitPercentageLabel">Прибыль: --%</div>
         <div id="costPercentageLabel">Затраты: --%</div>
       </div>
     </div>

     <div class="scroll-container w-full overflow-x-auto">
       <table id="resultsTable" class="result-table w-full text-sm text-center border-collapse">
         <thead>
           <tr>
             <th class="bg-black text-white p-0 w-24 align-middle">
               <div id="currencyButtonsContainer" class="flex justify-center items-center h-full">
                 <button id="currencyUSD" class="currency-btn w-7 h-7 active">$</button>
                 <button id="currencyRUB" class="currency-btn w-7 h-7 inactive">₽</button>
               </div>
             </th>
             <th class="bg-black text-white p-2">День</th>
             <th class="bg-black text-white p-2">Месяц</th>
             <th class="bg-black text-white p-2">Год</th>
           </tr>
         </thead>
         <tbody>
           <tr>
             <td class="bg-black text-white p-2 w-24">Доход</td>
             <td class="bg-[#E2E2E2] text-black p-2">
               <span class="text-[#2511A8] font-semibold" id="income">$ --.--</span>
               <span class="text-[#2511A8] font-semibold hidden" id="income_rub">-- ₽</span>
             </td>
             <td class="bg-[#E2E2E2] text-black p-2">
               <span class="text-[#2511A8] font-semibold" id="incomeMonth">$ --.--</span>
               <span class="text-[#2511A8] font-semibold hidden" id="incomeMonth_rub">-- ₽</span>
             </td>
             <td class="bg-[#E2E2E2] text-black p-2">
               <span class="text-[#2511A8] font-semibold" id="incomeYear">$ --.--</span>
               <span class="text-[#2511A8] font-semibold hidden" id="incomeYear_rub">-- ₽</span>
             </td>
           </tr>
           <tr>
             <td class="bg-black text-white p-2 w-24">Прибыль</td>
             <td class="bg-[#E2E2E2] text-black p-2">
               <span class="text-[#2511A8] font-semibold" id="profit">$ --.--</span>
               <span class="text-[#2511A8] font-semibold hidden" id="profit_rub">-- ₽</span>
             </td>
             <td class="bg-[#E2E2E2] text-black p-2">
               <span class="text-[#2511A8] font-semibold" id="profitMonth">$ --.--</span>
               <span class="text-[#2511A8] font-semibold hidden" id="profitMonth_rub">-- ₽</span>
             </td>
             <td class="bg-[#E2E2E2] text-black p-2">
               <span class="text-[#2511A8] font-semibold" id="profitYear">$ --.--</span>
               <span class="text-[#2511A8] font-semibold hidden" id="profitYear_rub">-- ₽</span>
             </td>
           </tr>
         </tbody>
       </table>
     </div>
     <div id="paybackRoiContainer" class="mt-4 text-black flex justify-between">
        <div>Окупаемость мес.: <span id="payback">—</span></div>
        <div>Годовой %: <span id="roi">—</span></div>
      </div>
   </div>

   <div id="tutorialModalOverlay" class="tutorial-modal-overlay"></div>
   <div id="tutorialModal" class="tutorial-modal">
       <h3 id="tutorialTitle">Добро пожаловать!</h3>
       <p id="tutorialText">Это краткое обучение поможет вам освоиться с калькулятором.</p>
       <button id="tutorialNextBtn" class="tutorial-modal-next-btn">Далее</button>
       <button id="tutorialSkipBtn" class="tutorial-modal-skip-btn">Пропустить</button>
   </div>

  <script>
// --- НАЧАЛО БЛОКА ОБУЧЕНИЯ ---
const SUPABASE_URL = 'https://yiprwrgmyqlkdmhgulmc.supabase.co'; // ВАШ URL
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlpcHJ3cmdteXFsa2RtaGd1bG1jIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ2NTI0NjgsImV4cCI6MjA2MDIyODQ2OH0.lfiTfr5ukGDEVuwq-X9U2kWs3nEZrp3N443HT5AkbfI'; // ВАШ ANON KEY

let supabaseClient;
try {
    supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
} catch (e) {
    console.error("Ошибка инициализации Supabase:", e);
}

let currentTutorialStep = 0;
let tutorialSteps = [];
let telegramUser = null;

const tutorialModalOverlay = document.getElementById('tutorialModalOverlay');
const tutorialModal = document.getElementById('tutorialModal');
const tutorialTitle = document.getElementById('tutorialTitle');
const tutorialText = document.getElementById('tutorialText');
const tutorialNextBtn = document.getElementById('tutorialNextBtn');
const tutorialSkipBtn = document.getElementById('tutorialSkipBtn');
let highlightedElement = null; 
let highlightedAncestors = []; 

async function initAppAndTutorial() {
    console.log("DOM fully loaded and parsed");
    Telegram.WebApp.ready();
    console.log("Telegram WebApp is ready.");

    try {
        await fetchData(); // Fetch currency data first
        await onAlgorithmChange(); // Then initialize algorithm dependent data
    } catch (error) {
        console.error("❌ Ошибка при начальной загрузке данных приложения:", error);
    }

    if (Telegram.WebApp.initDataUnsafe && Telegram.WebApp.initDataUnsafe.user) {
        telegramUser = Telegram.WebApp.initDataUnsafe.user;
        if (telegramUser.id) {
            console.log("Telegram User ID:", telegramUser.id);
            await checkTutorialStatus();
        } else {
            console.warn("Telegram User ID не найден. Обучение не будет запущено.");
        }
    } else {
        console.warn("Telegram WebApp данные пользователя не найдены. Обучение не будет запущено.");
        // Optionally, start tutorial anyway for non-Telegram environments or testing
        // setupTutorialStepsDefinition();
        // startTutorialFlow();
    }
}

async function checkTutorialStatus() {
    if (!supabaseClient) {
        console.error("Supabase не инициализирован. Обучение не будет запущено.");
        return;
    }
    console.log("Проверка статуса обучения для пользователя:", telegramUser.id);
    try {
        let { data: user, error } = await supabaseClient
            .from('users')
            .select('telegram_id, tutor')
            .eq('telegram_id', telegramUser.id.toString())
            .single();

        if (error && error.code !== 'PGRST116') { 
            console.error("Ошибка получения данных пользователя из Supabase:", error);
            return;
        }

        if (user && user.tutor === true) {
            console.log("Пользователь уже прошел обучение.");
        } else {
            if (!user) {
                console.log("Новый пользователь или не проходил обучение, запускаем.");
            } else {
                console.log("Пользователь не прошел обучение (tutor=false), запускаем.");
            }
            setupTutorialStepsDefinition();
            startTutorialFlow();
        }
    } catch (e) {
        console.error("Исключение при проверке статуса обучения:", e);
    }
}

function setupTutorialStepsDefinition() {
    tutorialSteps = [
        {
            title: "Шаг 1: Алгоритм",
            text: "Начните с выбора Алгоритма. Доступны SHA-256 (BTC) и Scrypt (LTC+DOGE).",
            elementId: "algorithmSelect",
        },
        {
            title: "Шаг 2: Производитель",
            text: "Отлично! Теперь выберите Производителя из списка.",
            elementId: "manufacturerSelect",
        },
        {
            title: "Шаг 3: Модель",
            text: "Выберите Модель. Характеристики (Хэшрейт и Потребление) подставятся автоматически.",
            elementId: "asicModel",
        },
        {
            title: "Шаг 4: Стоимость Электроэнергии",
            text: "Укажите Стоимость Электроэнергии за 1 кВт/ч.",
            elementId: "electricityCost",
        },
        {
            title: "Шаг 5: Стоимость Оборудования",
            text: "Стоимость оборудования автоматически подтягивается из нашего прайса. Можно указать свою цену.",
            elementId: "asicCost",
        },
        {
            title: "Шаг 6: Расчет",
            text: "Нажмите кнопку Рассчитать, чтобы увидеть результаты.",
            elementId: "calculateBtn",
        },
        {
            title: "Шаг 7: Шкала Прибыль-Затраты",
            text: "Здесь вы видите шкалу Прибыль-Затраты в общем Доходе.",
            elementId: "progressBarContainer",
        },
        {
            title: "Шаг 8: Таблица Доход/Прибыль",
            text: "В таблице с Доходом и Прибылью вы можете переключать валюту ($/₽).",
            elementId: "resultsTable", 
        },
        {
            title: "Шаг 9: Окупаемость и ROI",
            text: "И, конечно, показатели Окупаемости и Годовой возврат инвестиций (ROI).",
            elementId: "paybackRoiContainer",
        },
        {
            title: "Обучение завершено!",
            text: "Удачных расчетов!",
            elementId: null,
        }
    ];
}

function startTutorialFlow() {
    currentTutorialStep = 0;
    tutorialModalOverlay.style.display = 'block';
    tutorialModal.style.display = 'block';
    document.body.classList.add('tutorial-active'); 
    Telegram.WebApp.expand(); 
    displayCurrentTutorialStep();
}

function removeHighlight() {
    if (highlightedElement) {
        highlightedElement.classList.remove('tutorial-highlight');
        highlightedElement.classList.remove('tutorial-highlighted-ancestor'); 
        highlightedElement = null;
    }
    highlightedAncestors.forEach(ancestor => ancestor.classList.remove('tutorial-highlighted-ancestor'));
    highlightedAncestors = [];

    document.querySelectorAll('.tutorial-highlight').forEach(el => el.classList.remove('tutorial-highlight'));
    document.querySelectorAll('.tutorial-highlighted-ancestor').forEach(el => el.classList.remove('tutorial-highlighted-ancestor'));
}

function displayCurrentTutorialStep() {
    removeHighlight(); 

    if (currentTutorialStep >= tutorialSteps.length) {
        completeTutorialProcess();
        return;
    }

    const step = tutorialSteps[currentTutorialStep];
    tutorialTitle.textContent = step.title;
    tutorialText.innerHTML = step.text; 

    if (step.elementId) {
        const targetElement = document.getElementById(step.elementId);
        if (targetElement) {
            highlightedElement = targetElement;
            highlightedElement.classList.add('tutorial-highlight');
            highlightedElement.classList.add('tutorial-highlighted-ancestor'); 

            let parent = targetElement.parentElement;
            while (parent && parent !== document.body) {
                parent.classList.add('tutorial-highlighted-ancestor');
                highlightedAncestors.push(parent);
                parent = parent.parentElement;
            }

            targetElement.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
        } else {
            console.warn(`Элемент для обучения с ID "${step.elementId}" не найден.`);
        }
        if (step.alsoHighlight) { // Note: alsoHighlight was in a previous version, ensure tutorialSteps is updated if used
            const alsoElement = document.getElementById(step.alsoHighlight);
            if (alsoElement) {
                alsoElement.classList.add('tutorial-highlight');
                alsoElement.classList.add('tutorial-highlighted-ancestor'); 
                 let parentAlso = alsoElement.parentElement;
                 while (parentAlso && parentAlso !== document.body) {
                    if (!highlightedAncestors.includes(parentAlso)) { 
                        parentAlso.classList.add('tutorial-highlighted-ancestor');
                        highlightedAncestors.push(parentAlso);
                    }
                    parentAlso = parentAlso.parentElement;
                }
            }
        }
    }

    if (currentTutorialStep === tutorialSteps.length - 1) {
        tutorialNextBtn.textContent = "Завершить";
    } else {
        tutorialNextBtn.textContent = "Далее";
    }
}

tutorialNextBtn.addEventListener('click', () => {
    currentTutorialStep++;
    displayCurrentTutorialStep();
});

tutorialSkipBtn.addEventListener('click', () => {
    completeTutorialProcess(true); 
});

async function completeTutorialProcess(skipped = false) {
    tutorialModalOverlay.style.display = 'none';
    tutorialModal.style.display = 'none';
    document.body.classList.remove('tutorial-active'); 
    removeHighlight();
    console.log(skipped ? "Обучение пропущено." : "Обучение завершено.");

    if (!telegramUser || !telegramUser.id || !supabaseClient) {
        console.warn("Не удалось сохранить статус обучения: нет пользователя или Supabase клиента.");
        return;
    }

    try {
        const { data, error } = await supabaseClient
            .from('users')
            .upsert(
                {
                    telegram_id: telegramUser.id.toString(),
                    tutor: true,
                    updated_at: new Date().toISOString()
                },
                {
                    onConflict: 'telegram_id', 
                }
            )
            .select(); 

        if (error) {
            console.error("Ошибка сохранения статуса обучения в Supabase:", error);
        } else {
            console.log("Статус обучения успешно сохранен в Supabase:", data);
        }
    } catch (e) {
        console.error("Исключение при сохранении статуса обучения:", e);
    }
}

// --- КОНЕЦ БЛОКА ОБУЧЕНИЯ ---


// Ваш существующий код далее:
let jsonData = [];
let currentAlgorithm = "SHA-256";
let dailyIncome = 0;
let dailyProfitValue = 0; 
let dailyElectricityCostValue = 0; 
let monthlyProfit = 0;
let yearlyProfit = 0;
let usdtPrice = 0; 
let isUSD = true; 

let currentModelVariants = []; // For storing variants of the currently selected model

document.addEventListener("DOMContentLoaded", initAppAndTutorial); 

async function fetchData() {
    console.log("Загрузка kursBTC.txt...");
    try {
        const response = await fetch("https://hamsauno.github.io/Miner/kursBTC.txt");
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const text = await response.text();
        const data = text.trim().split("\n");
        console.log("✅ Строки из kursBTC.txt:", data);

        if (data.length >= 9) {
            const values = {
                btcPrice: parseFloat(data[0]),
                usdtPrice: parseFloat(data[1]), 
                profitPerTH: parseFloat(data[2]),
                ltcPrice: parseFloat(data[3]),
                dogePrice: parseFloat(data[4]),
                bellPrice: parseFloat(data[5]),
                profitPerLTC: parseFloat(data[6]),
                profitPerDOGE: parseFloat(data[7]),
                profitPerBELL: parseFloat(data[8]),
            };

            let dataValid = true;
            Object.entries(values).forEach(([key, val]) => {
                if (isNaN(val)) {
                    console.warn(`⚠️ Некорректное значение для ${key} из TXT:`, data[Object.keys(values).indexOf(key)]);
                    dataValid = false;
                }
                const el = document.getElementById(key);
                if (el && !isNaN(val)) {
                    el.value = val.toFixed(key.startsWith("profit") ? 8 : 2); 
                    if (key === "usdtPrice") {
                        usdtPrice = val; 
                        console.log(`Курс USDT обновлен: ${usdtPrice}`);
                    }
                } else if (!el) {
                     console.warn(`⚠️ Элемент с ID ${key} не найден для установки значения из TXT.`);
                }
            });

            if (!dataValid) {
                console.warn("Внимание: Некоторые данные из kursBTC.txt не удалось прочитать корректно.");
            } else {
                console.log("📥 Значения из TXT успешно загружены и установлены.");
            }
        } else {
            console.warn("❗ Недостаточно строк в kursBTC.txt. Ожидалось 9 или больше.");
        }
    } catch (e) {
        console.error("❌ Критическая ошибка загрузки kursBTC.txt:", e);
        const calcBtn = document.getElementById('calculateBtn');
        if(calcBtn) calcBtn.disabled = true;
    }
}


async function fetchJsonData() {
    console.log(`Загрузка calc.json для алгоритма: ${currentAlgorithm}...`);
    try {
        const response = await fetch("https://hamsauno.github.io/Miner/json/calc.json");
         if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        // Filter by algorithm immediately after fetching
        jsonData = data["Расчёты"] ? data["Расчёты"] : [];
        console.log(`✅ Загружено ${jsonData.length} всего моделей, будет отфильтровано по алгоритму.`);
        if (jsonData.length === 0) {
             console.warn(`⚠️ Модели не найдены в calc.json`);
        }
    } catch (e) {
        console.error(`❌ Ошибка загрузки или парсинга calc.json:`, e);
        jsonData = [];
        const manufacturerSelect = document.getElementById("manufacturerSelect");
        const modelSelect = document.getElementById("asicModel");
        if (manufacturerSelect) manufacturerSelect.innerHTML = '<option>Ошибка загрузки</option>';
        if (modelSelect) modelSelect.innerHTML = '<option>Ошибка загрузки</option>';
    }
}

async function onAlgorithmChange() {
    const algorithmSelect = document.getElementById("algorithmSelect");
    if (!algorithmSelect) return;
    currentAlgorithm = algorithmSelect.value;
    console.log(`Алгоритм изменен на: ${currentAlgorithm}`);

    // Fetch data if not already fetched, or if you want to re-fetch (though current setup fetches once)
    if (jsonData.length === 0) { // Only fetch if jsonData is empty, assuming it's algorithm-agnostic initially
        await fetchJsonData();
    }

    const manufacturerSelect = document.getElementById("manufacturerSelect");
    if (!manufacturerSelect) return;
// Filter jsonData by the current algorithm for manufacturer population
const modelsForCurrentAlgorithm = jsonData.filter(item => item["Алгоритм"] === currentAlgorithm);

const uniqueManufacturers = [...new Set(modelsForCurrentAlgorithm.map(item => item["Производитель"]?.toLowerCase() || 'unknown'))]
    .filter(m => m !== 'unknown')
    .sort();

    manufacturerSelect.innerHTML = "";

    if (uniqueManufacturers.length > 0) {
        uniqueManufacturers.forEach(m => {
            const opt = document.createElement("option");
            opt.value = m;
            opt.textContent = m.charAt(0).toUpperCase() + m.slice(1);
            manufacturerSelect.appendChild(opt);
        });
        manufacturerSelect.disabled = false;
         console.log(`Производители для ${currentAlgorithm} обновлены.`);
        updateModelList(); // This will further filter by manufacturer AND algorithm
    } else {
        manufacturerSelect.innerHTML = '<option>Нет данных</option>';
        manufacturerSelect.disabled = true;
        const modelSelect = document.getElementById("asicModel");
         if (modelSelect) {
             modelSelect.innerHTML = '<option>Нет данных</option>';
             modelSelect.disabled = true;
         }
         updateAsicSpecs(); // Clear specs
         console.warn(`Производители для ${currentAlgorithm} не найдены.`);
    }
}


function updateModelList() {
    const manufacturerSelect = document.getElementById("manufacturerSelect");
    const modelSelect = document.getElementById("asicModel");
    if (!manufacturerSelect || !modelSelect) return;

    const selectedManufacturer = manufacturerSelect.value?.toLowerCase();
    console.log(`Выбран производитель: ${selectedManufacturer}`);
    modelSelect.innerHTML = "";

    // Filter by currentAlgorithm AND selectedManufacturer
    const modelsForManufacturerAndAlgorithm = jsonData.filter(item => 
        item["Алгоритм"] === currentAlgorithm &&
        item["Производитель"]?.toLowerCase() === selectedManufacturer
    );

    const uniqueModels = [...new Set(
        modelsForManufacturerAndAlgorithm.map(item => item["Модель"])
    )].sort();

    if (uniqueModels.length > 0) {
        uniqueModels.forEach(modelName => {
            const opt = document.createElement("option");
            opt.value = modelName; 
            opt.textContent = modelName;
            modelSelect.appendChild(opt);
        });
        modelSelect.disabled = false;
        console.log(`Модели для ${selectedManufacturer} (${currentAlgorithm}) обновлены.`);
    } else {
        modelSelect.innerHTML = '<option>Нет моделей</option>';
        modelSelect.disabled = true;
        console.warn(`Модели для ${selectedManufacturer} (${currentAlgorithm}) не найдены.`);
    }
    updateAsicSpecs(); 
}


function updateAsicSpecs() {
    const modelSelect = document.getElementById("asicModel");
    const asicCostInput = document.getElementById("asicCost");
    const hashrateContainer = document.getElementById("hashrateContainer");
    const powerEl = document.getElementById("power");
    const powerUnitEl = document.getElementById("power_unit");

    if (!modelSelect || !asicCostInput || !hashrateContainer || !powerEl || !powerUnitEl) {
        console.error("Один из элементов для обновления характеристик ASIC не найден.");
        return;
    }

    hashrateContainer.innerHTML = '<span id="hashrate"></span>&nbsp;<span id="edprice"></span>'; // Reset to spans
    document.getElementById("hashrate").textContent = '';
    document.getElementById("edprice").textContent = '';
    powerEl.textContent = '';
    powerUnitEl.textContent = '';
    asicCostInput.value = '';
    asicCostInput.placeholder = 'Выберите модель';
    currentModelVariants = []; // Reset variants

    const selectedModelName = modelSelect.value;
    if (!selectedModelName || modelSelect.selectedOptions.length === 0 || modelSelect.selectedOptions[0].disabled || modelSelect.selectedOptions[0].textContent === "Нет моделей" || modelSelect.selectedOptions[0].textContent === "Нет данных" || modelSelect.selectedOptions[0].textContent === "Ошибка загрузки" ) {
        console.log("Нет выбранной модели или выбрана заглушка.");
        return;
    }

    currentModelVariants = jsonData.filter(i => 
        i["Модель"] === selectedModelName && 
        i["Алгоритм"] === currentAlgorithm // Ensure correct algorithm
    );

    if (currentModelVariants.length > 0) {
        if (currentModelVariants.length === 1) {
            const item = currentModelVariants[0];
            // Explicitly ensure the span structure is there before populating
            hashrateContainer.innerHTML = `<span id="hashrate"></span>&nbsp;<span id="edprice"></span>`;
            document.getElementById("hashrate").textContent = item["Хешрейт"] || '';
            document.getElementById("edprice").textContent = item["Ед. изм."] || '';
            populateSpecsForVariant(item);
        } else {
            // Sort variants by hashrate (assuming hashrate is numeric or can be parsed to numeric)
            currentModelVariants.sort((a, b) => parseFloat(a["Хешрейт"]) - parseFloat(b["Хешрейт"]));

            let selectHTML = '<select id="hashrateSelect" class="bg-[#E2E2E2] w-full px-1 py-0 border border-gray-400 text-black text-sm focus:outline-none focus:ring-2 focus:ring-yellow-400 rounded-none appearance-menulist">';
            currentModelVariants.forEach((variant, index) => {
                selectHTML += `<option value="${index}">${variant["Хешрейт"]} ${variant["Ед. изм."]}</option>`;
            });
            selectHTML += '</select>';
            hashrateContainer.innerHTML = selectHTML;

            const hashrateSelect = document.getElementById("hashrateSelect");
            hashrateSelect.addEventListener('change', function() {
                populateSpecsForVariant(currentModelVariants[this.value]);
            });
            populateSpecsForVariant(currentModelVariants[0]); // Populate with the first variant initially
        }
    } else {
        console.warn(`Данные для модели ${selectedModelName} (${currentAlgorithm}) не найдены.`);
        asicCostInput.placeholder = 'Данные не найдены';
    }
}

function populateSpecsForVariant(item) {
    if (!item) {
        // Clear fields if no item
        document.getElementById("power").textContent = '';
        document.getElementById("power_unit").textContent = '';
        document.getElementById("asicCost").value = '';
        document.getElementById("asicCost").placeholder = 'Данные не найдены';
        return;
    }
    
    const powerEl = document.getElementById("power");
    const powerUnitEl = document.getElementById("power_unit");
    const asicCostInput = document.getElementById("asicCost");

    const powerValue = parseFloat(item["Потребление"]);
    if (!isNaN(powerValue)) {
        powerEl.textContent = Math.round(powerValue);
        powerUnitEl.textContent = ' Вт';
    } else {
        powerEl.textContent = '';
        powerUnitEl.textContent = '';
        console.warn("Некорректное значение потребления:", item["Потребление"]);
    }

    const itemPriceUSD = parseFloat(item["Цена"]);
    if (!isNaN(itemPriceUSD) && usdtPrice > 0) {
        const calculatedCostRUB = itemPriceUSD * usdtPrice;
        asicCostInput.value = Math.ceil(calculatedCostRUB / 100) * 100; // Округление до ближайших 100 рублей вверх
    } else {
        asicCostInput.value = '';
        asicCostInput.placeholder = (usdtPrice <= 0 && !isNaN(itemPriceUSD)) ? 'Курс USDT ?' : 'Цена не найдена';
        console.warn(`Не удалось рассчитать стоимость ASIC. Цена: ${item["Цена"]}, Курс USDT: ${usdtPrice}`);
    }
    console.log("Характеристики обновлены для варианта:", item);
}


function showNotification() {
    const notification = document.getElementById('notification');
    if (notification) {
        notification.classList.remove('hidden');
        setTimeout(() => {
            notification.classList.add('hidden');
        }, 1000);
    }
}


function calculateProfit() {
    console.log("Начало расчета...");
    const elements = {
        usdtPriceInput: document.getElementById("usdtPrice"),
        // hashrateEl will be handled dynamically
        powerEl: document.getElementById("power"),
        electricityCostInput: document.getElementById('electricityCost'),
        asicCostInput: document.getElementById("asicCost"),
        btcPriceInput: document.getElementById("btcPrice"),
        profitPerTHInput: document.getElementById("profitPerTH"),
        ltcPriceInput: document.getElementById("ltcPrice"),
        dogePriceInput: document.getElementById("dogePrice"),
        bellPriceInput: document.getElementById("bellPrice"),
        profitPerLTCInput: document.getElementById("profitPerLTC"),
        profitPerDOGEInput: document.getElementById("profitPerDOGE"),
        profitPerBELLInput: document.getElementById("profitPerBELL"),
        incomeEl: document.getElementById("income"),
        incomeRubEl: document.getElementById("income_rub"),
        profitEl: document.getElementById("profit"),
        profitRubEl: document.getElementById("profit_rub"),
        incomeMonthEl: document.getElementById("incomeMonth"),
        incomeMonthRubEl: document.getElementById("incomeMonth_rub"),
        incomeYearEl: document.getElementById("incomeYear"),
        incomeYearRubEl: document.getElementById("incomeYear_rub"),
        profitMonthEl: document.getElementById("profitMonth"),
        profitMonthRubEl: document.getElementById("profitMonth_rub"),
        profitYearEl: document.getElementById("profitYear"),
        profitYearRubEl: document.getElementById("profitYear_rub"),
        roiEl: document.getElementById("roi"),
        paybackEl: document.getElementById("payback"),
        profitBar: document.getElementById("dailyProfitBar"),
        electricityBar: document.getElementById("dailyElectricityCostBar"),
        profitPercentageLabel: document.getElementById("profitPercentageLabel"),
        costPercentageLabel: document.getElementById("costPercentageLabel")
    };

    for (const key in elements) {
        if (!elements[key]) {
            console.error(`❌ Ошибка: Элемент ${key} не найден! Расчет прерван.`);
            return;
        }
    }
     console.log("Все элементы для расчета найдены.");

    let actualHashrate;
    let selectedVariantHashrateUnit = ''; // To store "TH/s", "MH/s", etc.
    const hashrateSelect = document.getElementById("hashrateSelect");

    if (hashrateSelect && currentModelVariants.length > 0 && hashrateSelect.value !== "") {
        const selectedVariant = currentModelVariants[hashrateSelect.value];
        if (selectedVariant) {
            actualHashrate = parseFloat(selectedVariant["Хешрейт"]);
            selectedVariantHashrateUnit = selectedVariant["Ед. изм."]; // e.g., "TH/s"
        } else {
            console.error("❌ Ошибка: Выбранный вариант хешрейта не найден."); return;
        }
    } else {
        const hashrateSpan = document.getElementById("hashrate"); // The static span
        if (hashrateSpan) {
            actualHashrate = parseFloat(hashrateSpan.textContent);
            const edpriceSpan = document.getElementById("edprice"); // The unit span
            if (edpriceSpan) selectedVariantHashrateUnit = edpriceSpan.textContent;
        } else {
            console.error("❌ Ошибка: Элемент хешрейта не найден."); return;
        }
    }

    // Convert hashrate to base unit if necessary (e.g. TH/s for SHA-256, MH/s for Scrypt)
    // For SHA-256, profitPerTH is usually per TH.
    // For Scrypt, profitPerLTC/DOGE/BELL might be per MH. Adjust this logic based on your profitPer... units.
    // This example assumes profitPerTH is for TH/s and Scrypt profit rates are for MH/s
    let calculationHashrate = actualHashrate;
    if (currentAlgorithm === "SHA-256") {
        if (selectedVariantHashrateUnit.toUpperCase().includes("GH")) calculationHashrate /= 1000;
        if (selectedVariantHashrateUnit.toUpperCase().includes("MH")) calculationHashrate /= 1000000;
    } else if (currentAlgorithm === "Scrypt") {
        if (selectedVariantHashrateUnit.toUpperCase().includes("TH")) calculationHashrate *= 1000000;
        if (selectedVariantHashrateUnit.toUpperCase().includes("GH")) calculationHashrate *= 1000;
        // if it's MH/s, it's already the base for profitPer... values (assumption)
    }


    const values = {
        currentUsdtPrice: parseFloat(elements.usdtPriceInput.value),
        hashrate: calculationHashrate, // Use the potentially converted hashrate for calculation
        power: parseFloat(elements.powerEl.textContent),
        electricityCost: parseFloat(elements.electricityCostInput.value.replace(',', '.')),
        asicCost: parseFloat(elements.asicCostInput.value)
    };

     const baseValuesValid = !isNaN(values.currentUsdtPrice) && values.currentUsdtPrice > 0 &&
                            !isNaN(values.hashrate) && values.hashrate > 0 &&
                            !isNaN(values.power) && values.power >= 0 &&
                            !isNaN(values.electricityCost) && values.electricityCost >= 0 &&
                            !isNaN(values.asicCost) && values.asicCost >= 0;

    if (!baseValuesValid) {
         console.error("❌ Ошибка: Некорректные базовые значения для расчета.", values);
         return;
    }
     console.log("Базовые значения для расчета:", values);

    dailyIncome = 0; 
    if (currentAlgorithm === "SHA-256") {
        const btcPrice = parseFloat(elements.btcPriceInput.value);
        const profitPerTH = parseFloat(elements.profitPerTHInput.value);
        if (!isNaN(btcPrice) && !isNaN(profitPerTH)) {
            dailyIncome = values.hashrate * profitPerTH * btcPrice; // Assuming values.hashrate is in TH/s
        } else {
             console.error("❌ Ошибка: Некорректные данные BTC или ProfitPerTH.");
             return;
        }
    } else if (currentAlgorithm === "Scrypt") {
        const ltcPrice = parseFloat(elements.ltcPriceInput.value);
        const dogePrice = parseFloat(elements.dogePriceInput.value);
        const bellPrice = parseFloat(elements.bellPriceInput.value);
        const profitPerLTC = parseFloat(elements.profitPerLTCInput.value);
        const profitPerDOGE = parseFloat(elements.profitPerDOGEInput.value);
        const profitPerBELL = parseFloat(elements.profitPerBELLInput.value);
         if (!isNaN(ltcPrice) && !isNaN(dogePrice) && !isNaN(bellPrice) &&
            !isNaN(profitPerLTC) && !isNaN(profitPerDOGE) && !isNaN(profitPerBELL))
         {
            // Assuming values.hashrate is in MH/s for Scrypt calculations and profitPer... are per MH/s
            const incomeLTC = values.hashrate * profitPerLTC * ltcPrice; 
            const incomeDOGE = values.hashrate * profitPerDOGE * dogePrice;
            const incomeBELL = values.hashrate * profitPerBELL * bellPrice;
            dailyIncome = incomeLTC + incomeDOGE + incomeBELL;
         } else {
              console.error("❌ Ошибка: Некорректные данные для расчета Scrypt.");
              return;
         }
    }
     console.log(`Дневной доход ($): ${dailyIncome}`);

    const dailyElectricityCostRub = (values.power / 1000) * values.electricityCost * 24;
    dailyElectricityCostValue = values.currentUsdtPrice > 0 ? dailyElectricityCostRub / values.currentUsdtPrice : 0; 
    console.log(`Дневные расходы на электричество ($): ${dailyElectricityCostValue}`);

    window.dailyProfitValue = dailyIncome - dailyElectricityCostValue; 

    monthlyProfit = window.dailyProfitValue * 30.5; 
    yearlyProfit = window.dailyProfitValue * 365;   
    console.log(`Дневная прибыль ($): ${window.dailyProfitValue}`);

    const asicCostInUSD = values.currentUsdtPrice > 0 ? values.asicCost / values.currentUsdtPrice : Infinity;
    const roi = (yearlyProfit && asicCostInUSD > 0 && isFinite(asicCostInUSD)) ? (yearlyProfit / asicCostInUSD) * 100 : 0;
    const payback = (window.dailyProfitValue > 0 && asicCostInUSD > 0 && isFinite(asicCostInUSD)) ? (asicCostInUSD / window.dailyProfitValue) / 30.5 : Infinity;
    console.log(`Стоимость асика ($): ${asicCostInUSD}, Годовой ROI: ${roi}%, Окупаемость (мес): ${payback}`);

    updateTableValues();
    updateProgressBarAndLabels(elements);

    elements.roiEl.innerText = isFinite(roi) ? roi.toFixed(1) : "—";
    elements.paybackEl.innerText = isFinite(payback) ? payback.toFixed(1) : "—";

    showNotification();

    console.log("Расчет завершен, интерфейс обновлен.");
}

function formatCurrency(value, currency = "$", fractionDigits = 2) {
    if (isNaN(value) || !isFinite(value)) return currency === "$" ? "$ --.--" : "--.-- ₽";
    const multiplier = Math.pow(10, fractionDigits);
    const roundedValue = Math.round(value * multiplier) / multiplier;
    return currency + roundedValue.toLocaleString('ru-RU', { minimumFractionDigits: fractionDigits, maximumFractionDigits: fractionDigits });
};
 function formatCurrencyRub(value, fractionDigits = 0) {
    if (isNaN(value) || !isFinite(value) || isNaN(usdtPrice) || usdtPrice <= 0) return "-- ₽";
    const rubValue = value * usdtPrice;
     const multiplier = Math.pow(10, fractionDigits);
    const roundedValue = Math.round(rubValue * multiplier) / multiplier;
    return roundedValue.toLocaleString('ru-RU', { maximumFractionDigits: fractionDigits }) + " ₽";
};


function updateTableValues() {
    const elementsToToggle = [
        "income", "incomeMonth", "incomeYear",
        "profit", "profitMonth", "profitYear"
    ];

    elementsToToggle.forEach(id => {
        const usdEl = document.getElementById(id);
        const rubEl = document.getElementById(`${id}_rub`);
        if (usdEl && rubEl) {
            let valueUSD = 0;
            if (id.startsWith("incomeMonth")) valueUSD = dailyIncome * 30.5;
            else if (id.startsWith("incomeYear")) valueUSD = dailyIncome * 365;
            else if (id.startsWith("income")) valueUSD = dailyIncome;
            else if (id.startsWith("profitMonth")) valueUSD = monthlyProfit; 
            else if (id.startsWith("profitYear")) valueUSD = yearlyProfit;  
            else if (id.startsWith("profit")) valueUSD = window.dailyProfitValue; 

            usdEl.innerText = formatCurrency(valueUSD);
            rubEl.innerText = formatCurrencyRub(valueUSD);

            if (isUSD) {
                usdEl.classList.remove("hidden");
                rubEl.classList.add("hidden");
            } else {
                usdEl.classList.add("hidden");
                rubEl.classList.remove("hidden");
            }
        } else {
            console.warn(`Элементы для переключения валюты ${id} / ${id}_rub не найдены.`);
        }
    });
}

function setCurrency(setToUSD) {
    if (isUSD === setToUSD) return;

    isUSD = setToUSD;
    const usdBtn = document.getElementById('currencyUSD');
    const rubBtn = document.getElementById('currencyRUB');

    if (usdBtn && rubBtn) {
        if (isUSD) {
            usdBtn.classList.remove('inactive');
            usdBtn.classList.add('active');
            rubBtn.classList.remove('active');
            rubBtn.classList.add('inactive');
        } else {
            usdBtn.classList.remove('active');
            usdBtn.classList.add('inactive');
            rubBtn.classList.remove('inactive');
            rubBtn.classList.add('active');
        }
        updateTableValues();
        console.log(`Валюта переключена на: ${isUSD ? 'USD' : 'RUB'}`);
    } else {
        console.warn("Кнопки валют не найдены.");
    }
}

function updateProgressBarAndLabels(elements) {
    const profitBar = elements.profitBar;
    const electricityBar = elements.electricityBar;
    const profitLabel = elements.profitPercentageLabel;
    const costLabel = elements.costPercentageLabel;

    let profitPercentage = 0;
    let electricityPercentage = 0;

    if (dailyIncome > 0 && isFinite(dailyIncome) && isFinite(dailyElectricityCostValue)) {
        profitPercentage = Math.max(0, (window.dailyProfitValue / dailyIncome) * 100);
        electricityPercentage = Math.max(0, (dailyElectricityCostValue / dailyIncome) * 100);

        if (window.dailyProfitValue <= 0) { 
            profitPercentage = 0;
            electricityPercentage = 100; 
        } else if (profitPercentage + electricityPercentage > 100.1) { 
             electricityPercentage = 100 - profitPercentage;
        }

        profitPercentage = Math.min(100, Math.max(0, profitPercentage));
        electricityPercentage = Math.min(100, Math.max(0, electricityPercentage));

        profitBar.style.width = `${profitPercentage.toFixed(1)}%`;
        electricityBar.style.width = `${electricityPercentage.toFixed(1)}%`;
        electricityBar.style.left = `${profitPercentage.toFixed(1)}%`;

        profitLabel.textContent = `Прибыль: ${profitPercentage.toFixed(1)}%`;
        costLabel.textContent = `Затраты: ${electricityPercentage.toFixed(1)}%`;

    } else {
        profitBar.style.width = "0%";
        electricityBar.style.width = "0%";
        electricityBar.style.left = "0%";
        profitLabel.textContent = `Прибыль: --%`;
        costLabel.textContent = `Затраты: --%`;
    }
}

const algorithmSelect = document.getElementById("algorithmSelect");
const manufacturerSelect = document.getElementById("manufacturerSelect");
const asicModelSelect = document.getElementById("asicModel"); 
const calculateBtn = document.getElementById("calculateBtn"); 
const currencyUSD_Btn = document.getElementById('currencyUSD');
const currencyRUB_Btn = document.getElementById('currencyRUB');

if (algorithmSelect) algorithmSelect.addEventListener("change", onAlgorithmChange);
if (manufacturerSelect) manufacturerSelect.addEventListener("change", updateModelList);
if (asicModelSelect) asicModelSelect.addEventListener("change", updateAsicSpecs); 
if (calculateBtn) calculateBtn.addEventListener("click", calculateProfit);     
if (currencyUSD_Btn) currencyUSD_Btn.addEventListener('click', () => setCurrency(true));
if (currencyRUB_Btn) currencyRUB_Btn.addEventListener('click', () => setCurrency(false));

  </script>
</body>
</html>
