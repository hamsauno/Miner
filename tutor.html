<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<title>Калькулятор доходности майнинга</title>
<meta name="description" content="Удобный Telegram-калькулятор для расчета доходности ASIC-майнеров. Доход, прибыль, ROI, окупаемость — всё в одном месте.">
<style>
  html, body {
    overscroll-behavior-y: none; /* запрещает "отпружинивание" на iOS и Android */
    touch-action: pan-y; /* безопасно включает вертикальный и горизонтальный скролл */
  }
  /* Ensure no rounded corners */
  input, select {
    border-radius: 0 !important;
    -webkit-appearance: none; /* Remove default iOS styling */
    -moz-appearance: none; /* Remove default Firefox styling */
    appearance: none; /* Remove default styling */
  }
  /* Style for currency buttons */
  .currency-btn {
    border: none;
    padding: 0.5rem;
    margin: 0;
    font-size: 0.75rem;
    font-weight: bold;
    transition: background-color 0.3s, color 0.3s;
    width: 50%;
    line-height: 1;
    height: 100%;
  }
  .currency-btn.active {
    background-color: #E2E2E2;
    color: black;
  }
  .currency-btn.inactive {
    background-color: #2511A8;
    color: white;
  }
  .currency-btn:hover {
    filter: brightness(110%);
  }
  /* Remove spinner buttons from number inputs */
  input[type=number]::-webkit-inner-spin-button,
  input[type=number]::-webkit-outer-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  /* Стили для модального окна обучения */
  .tutorial-modal-overlay {
      display: none;
      position: fixed;
      z-index: 9998;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.8);
      pointer-events: auto;
  }

  .tutorial-modal {
      display: none;
      position: fixed; /* Will be adjusted by JS */
      z-index: 10000;
      background-color: #1F2937;
      color: #F3F4F6;
      padding: 15px;
      border: 1px solid #4B5563;
      width: 80%;
      max-width: 350px;
      border-radius: 0;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      text-align: center;
  }
  .tutorial-modal h3 {
      margin-top: 0;
      margin-bottom: 10px;
      font-size: 1.1rem;
      font-weight: 600;
  }
  .tutorial-modal p {
      margin-bottom: 15px;
      font-size: 0.8rem;
      line-height: 1.4;
  }
  .tutorial-modal button {
      padding: 8px 12px;
      font-size: 0.8rem;
      font-weight: 500;
      cursor: pointer;
      border: none;
      border-radius: 0;
      transition: background-color 0.2s;
  }
  .tutorial-modal-next-btn {
      background-color: #2563EB;
      color: white;
  }
  .tutorial-modal-next-btn:hover {
      background-color: #1D4ED8;
  }
  .tutorial-modal-skip-btn {
      background-color: #4B5563;
      color: #F3F4F6;
      margin-left: 8px;
  }
  .tutorial-modal-skip-btn:hover {
      background-color: #374151;
  }

  /* Стиль для подсветки элемента */
  .tutorial-highlight {
      box-shadow: 0 0 0 3px #FBBF24, 0 0 15px 3px #FBBF24;
      border-radius: 0 !important;
      transition: box-shadow 0.3s ease-in-out;
      position: relative;
      z-index: 9999;
      pointer-events: auto;
  }

  /* Style for white text during tutorial highlight */
  .tutorial-text-white {
      color: white !important;
  }

  body.tutorial-active > *:not(.tutorial-modal-overlay):not(.tutorial-modal):not(.tutorial-highlighted-ancestor) {
      pointer-events: none !important;
  }
  .tutorial-highlighted-ancestor {
      pointer-events: auto !important;
  }

  /* Consistent height and styling for input-like display areas */
  #hashrateContainer, #powerContainer {
    height: 30px; /* Consistent height */
    display: flex;
    align-items: center;
    background-color: #E2E2E2; /* Match other inputs */
    padding-left: 0.5rem; /* px-2 */
    padding-right: 0.5rem; /* px-2 */
    box-sizing: border-box;
    border: 1px solid #9CA3AF; /* Optional: add border like other inputs */
    color: black; /* Text color */
    font-size: 0.875rem; /* text-sm */
  }

  #hashrateContainer select#hashrateSelect {
    height: 100%;
    width: 100%; /* Make select take full width of its container if needed */
    padding-top: 0.1rem;
    padding-bottom: 0.1rem;
    padding-left: 0.25rem;
    padding-right: 0.25rem;
    background-color: #E2E2E2; /* Ensure consistent bg */
    border: none; /* Remove default select border if container has one */
    /* border: 1px solid #9CA3AF; */ /* Or keep its own border */
    color: black;
    font-size: 0.875rem;
    border-radius: 0 !important;
    -webkit-appearance: menulist;
    -moz-appearance: menulist;
    appearance: menulist;
    box-sizing: border-box;
  }

  #hashrateContainer span, #powerContainer span {
    display: inline-block;
    line-height: normal; /* Adjust if needed */
  }
  /* Ensure the edprice span is visible and styled if select isn't present */
   #hashrateContainer > span#edprice {
       margin-left: 0.25rem; /* Add some space */
   }


</style>
</head>
<body class="bg-black">
    <div id="headerSection" class="w-full bg-[#000000] text-white shadow-xl p-5 mb-[3px]">
      <div class="form-content space-y-2">
         <div class="flex gap-3">
           <div class="w-1/2">
             <label for="algorithmSelect" class="block text-sm font-medium mb-1">Алгоритм</label>
             <select id="algorithmSelect"
               class="bg-[#E2E2E2] w-full px-2 py-1 border border-gray-400 text-black text-sm focus:outline-none focus:ring-2 focus:ring-yellow-400">
               <option value="SHA-256">SHA-256</option>
               <option value="Scrypt">SCRYPT</option>
             </select>
           </div>
           <div class="w-1/2">
             <label for="manufacturerSelect" class="block text-sm font-medium mb-1">Производитель</label>
             <select id="manufacturerSelect"
               class="bg-[#E2E2E2] w-full px-2 py-1 border border-gray-400 text-black text-sm focus:outline-none focus:ring-2 focus:ring-yellow-400">
               </select>
           </div>
         </div>

         <div>
           <label for="asicModel" class="block text-sm font-medium mb-1">Модель Оборудования</label>
           <select id="asicModel"
             class="bg-[#E2E2E2] w-full px-2 py-1 border border-gray-400 text-black text-sm focus:outline-none focus:ring-2 focus:ring-yellow-400">
             </select>
         </div>

         <div class="flex gap-3">
           <div class="w-1/2">
             <label class="block text-sm font-medium mb-1">Хэшрейт</label>
             <div id="hashrateContainer"> <span id="hashrate"></span><span id="edprice"></span>
             </div>
           </div>
           <div class="w-1/2">
             <label class="block text-sm font-medium mb-1">Потребление</label>
             <div id="powerContainer"> <span id="power"></span><span id="power_unit"></span>
             </div>
           </div>
         </div>

         <div class="flex gap-3">
           <div class="w-1/2">
             <label for="electricityCost" class="block text-sm font-medium mb-1">Стоимость <br> Электроэнергии</label>
             <div class="relative">
               <input
                 type="number"
                 id="electricityCost"
                 value="5"
                 inputmode="decimal"
                 step="any"
                 class="bg-[#E2E2E2] w-full px-2 py-1 pr-6 border border-gray-400 text-black text-sm focus:outline-none focus:ring-2 focus:ring-yellow-400">
               <span class="absolute right-2 top-1/2 -translate-y-1/2 text-black text-xs">₽</span>
             </div>
           </div>
           <div class="w-1/2">
             <label for="asicCost" class="block text-sm font-medium mb-1">Стоимость <br> Оборудования</label>
             <div class="relative">
               <input type="text" id="asicCost" inputmode="numeric" class="bg-[#E2E2E2] w-full px-2 py-1 pr-6 border border-gray-400 text-black text-sm focus:outline-none focus:ring-2 focus:ring-yellow-400"
                 placeholder="Авто/Ручной ввод"> <span class="absolute right-2 top-1/2 -translate-y-1/2 text-black text-xs">₽</span>
             </div>
           </div>
         </div>

         <input type="hidden" id="btcPrice">
         <input type="hidden" id="usdtPrice">
         <input type="hidden" id="profitPerTH">
         <input type="hidden" id="ltcPrice">
         <input type="hidden" id="dogePrice">
         <input type="hidden" id="bellPrice">
         <input type="hidden" id="profitPerLTC">
         <input type="hidden" id="profitPerDOGE">
         <input type="hidden" id="profitPerBELL">
      </div>
      <div class="button-container pt-2">
        <button id="calculateBtn"
          class="w-full text-white font-bold text-base py-2 px-4 transition duration-300 hover:brightness-110 shadow-md"
          style="background-color: #2511A8;">
          Рассчитать
        </button>
        <div id="notification" class="mt-2 p-2 text-center text-white bg-black hidden">
          Расчёт произведён
        </div>
      </div>
   </div>

   <div id="resultsContainer" class="w-full bg-[#E2E2E2] text-sm space-y-4 shadow-md px-4 pb-4 pt-4 text-black">
     <div id="dailyMetricsContainer"> <div id="progressBarContainer" class="w-full h-5 relative overflow-hidden border" style="border-color: #2511A8;">
         <div id="dailyProfitBar" class="absolute top-0 left-0 h-full transition-all duration-500" style="background-color: #2511A8;"></div>
         <div id="dailyElectricityCostBar" class="absolute top-0 h-full transition-all duration-500" style="background-color: #CCCCCC;"></div>
       </div>
       <div class="mt-1 text-xs flex justify-between overflow-hidden border">
         <div id="profitPercentageLabel">Прибыль: --%</div>
         <div id="costPercentageLabel">Затраты: --%</div>
       </div>
     </div>

     <div class="scroll-container w-full overflow-x-auto">
       <table id="resultsTable" class="result-table w-full text-sm text-center border-collapse">
         <thead>
           <tr>
             <th class="bg-black text-white p-0 w-24 align-middle">
               <div id="currencyButtonsContainer" class="flex justify-center items-center h-full">
                 <button id="currencyUSD" class="currency-btn w-7 h-7 active">$</button>
                 <button id="currencyRUB" class="currency-btn w-7 h-7 inactive">₽</button>
               </div>
             </th>
             <th class="bg-black text-white p-2">День</th>
             <th class="bg-black text-white p-2">Месяц</th>
             <th class="bg-black text-white p-2">Год</th>
           </tr>
         </thead>
         <tbody>
           <tr>
             <td class="bg-black text-white p-2 w-24">Доход</td>
             <td class="bg-[#E2E2E2] text-black p-2">
               <span class="text-[#2511A8] font-semibold" id="income">$ --.--</span>
               <span class="text-[#2511A8] font-semibold hidden" id="income_rub">-- ₽</span>
             </td>
             <td class="bg-[#E2E2E2] text-black p-2">
               <span class="text-[#2511A8] font-semibold" id="incomeMonth">$ --.--</span>
               <span class="text-[#2511A8] font-semibold hidden" id="incomeMonth_rub">-- ₽</span>
             </td>
             <td class="bg-[#E2E2E2] text-black p-2">
               <span class="text-[#2511A8] font-semibold" id="incomeYear">$ --.--</span>
               <span class="text-[#2511A8] font-semibold hidden" id="incomeYear_rub">-- ₽</span>
             </td>
           </tr>
           <tr>
             <td class="bg-black text-white p-2 w-24">Прибыль</td>
             <td class="bg-[#E2E2E2] text-black p-2">
               <span class="text-[#2511A8] font-semibold" id="profit">$ --.--</span>
               <span class="text-[#2511A8] font-semibold hidden" id="profit_rub">-- ₽</span>
             </td>
             <td class="bg-[#E2E2E2] text-black p-2">
               <span class="text-[#2511A8] font-semibold" id="profitMonth">$ --.--</span>
               <span class="text-[#2511A8] font-semibold hidden" id="profitMonth_rub">-- ₽</span>
             </td>
             <td class="bg-[#E2E2E2] text-black p-2">
               <span class="text-[#2511A8] font-semibold" id="profitYear">$ --.--</span>
               <span class="text-[#2511A8] font-semibold hidden" id="profitYear_rub">-- ₽</span>
             </td>
           </tr>
         </tbody>
       </table>
     </div>
     <div id="paybackRoiContainer" class="mt-4 flex justify-between"> <div id="paybackLabelContainer">Окупаемость мес.: <span id="payback">—</span></div>
        <div id="roiLabelContainer">Годовой %: <span id="roi">—</span></div>
      </div>
   </div>

   <div id="tutorialModalOverlay" class="tutorial-modal-overlay"></div>
   <div id="tutorialModal" class="tutorial-modal">
       <h3 id="tutorialTitle">Добро пожаловать!</h3>
       <p id="tutorialText">Это краткое обучение поможет вам освоиться с калькулятором.</p>
       <button id="tutorialNextBtn" class="tutorial-modal-next-btn">Далее</button>
       <button id="tutorialSkipBtn" class="tutorial-modal-skip-btn">Пропустить</button>
   </div>

<script>
// --- НАЧАЛО БЛОКА ОБУЧЕНИЯ ---
const SUPABASE_URL = 'https://yiprwrgmyqlkdmhgulmc.supabase.co'; // ВАШ URL
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlpcHJ3cmdteXFsa2RtaGd1bG1jIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ2NTI0NjgsImV4cCI6MjA2MDIyODQ2OH0.lfiTfr5ukGDEVuwq-X9U2kWs3nEZrp3N443HT5AkbfI'; // ВАШ ANON KEY

let supabaseClient;
try {
    supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
} catch (e) {
    console.error("Ошибка инициализации Supabase:", e);
}

let currentTutorialStep = 0;
let tutorialSteps = [];
let telegramUser = null;

const tutorialModalOverlay = document.getElementById('tutorialModalOverlay');
const tutorialModal = document.getElementById('tutorialModal');
const tutorialTitle = document.getElementById('tutorialTitle');
const tutorialText = document.getElementById('tutorialText');
const tutorialNextBtn = document.getElementById('tutorialNextBtn');
const tutorialSkipBtn = document.getElementById('tutorialSkipBtn');
let highlightedElement = null;
let highlightedAncestors = [];

async function initAppAndTutorial() {
    console.log("DOM fully loaded and parsed");
    Telegram.WebApp.ready();
    console.log("Telegram WebApp is ready.");

    try {
        await fetchData();
        await onAlgorithmChange(); // This will also call fetchJsonData if needed
    } catch (error) {
        console.error("❌ Ошибка при начальной загрузке данных приложения:", error);
    }
     // ADDED: Event listener for asicCost formatting
    const asicCostInput = document.getElementById("asicCost");
    if (asicCostInput) {
        asicCostInput.addEventListener('input', handleAsicCostInputFormatting);
    }


    if (Telegram.WebApp.initDataUnsafe && Telegram.WebApp.initDataUnsafe.user) {
        telegramUser = Telegram.WebApp.initDataUnsafe.user;
        if (telegramUser.id) {
            console.log("Telegram User ID:", telegramUser.id);
            await checkTutorialStatus();
        } else {
            console.warn("Telegram User ID не найден. Обучение не будет запущено.");
        }
    } else {
        console.warn("Telegram WebApp данные пользователя не найдены. Обучение не будет запущено.");
    }
}

async function checkTutorialStatus() {
    if (!supabaseClient || !telegramUser || !telegramUser.id) {
        console.error("Supabase или Telegram User не инициализирован. Обучение не будет запущено.");
        return;
    }
    console.log("Проверка статуса обучения для пользователя:", telegramUser.id);
    try {
        let { data: user, error } = await supabaseClient
            .from('users')
            .select('telegram_id, tutor')
            .eq('telegram_id', telegramUser.id.toString())
            .single();

        if (error && error.code !== 'PGRST116') { // PGRST116: no rows found, which is fine for a new user
            console.error("Ошибка получения данных пользователя из Supabase:", error);
            return;
        }

        if (user && user.tutor === true) {
            console.log("Пользователь уже прошел обучение.");
        } else {
            if (!user) {
                console.log("Новый пользователь или не проходил обучение, запускаем.");
            } else {
                console.log("Пользователь не прошел обучение (tutor=false), запускаем.");
            }
            setupTutorialStepsDefinition(); // Define steps
            startTutorialFlow(); // Start tutorial
        }
    } catch (e) {
        console.error("Исключение при проверке статуса обучения:", e);
    }
}

function setupTutorialStepsDefinition() {
    tutorialSteps = [
        { text: "Начните с выбора Алгоритма. Доступны SHA-256 (BTC) и Scrypt (LTC+DOGE).", elementId: "algorithmSelect" },
        { text: "Отлично! Теперь выберите Производителя из списка.", elementId: "manufacturerSelect" },
        { text: "Выберите интересующую вас Модель оборудования.", elementId: "asicModel" },
        { text: "Здесь отображается Хешрейт выбранной модели. Если модель имеет несколько вариантов хешрейта, вы сможете выбрать нужный из списка. Потребление подставится автоматически.", elementId: "hashrateContainer" }, // MODIFIED/NEW
        { text: "Укажите Стоимость Электроэнергии </br> за 1 кВт/ч.", elementId: "electricityCost" },
        { text: "Стоимость оборудования автоматически подтягивается из нашего прайса. Можно указать свою цену (в рублях).", elementId: "asicCost" },
        { text: "Нажмите кнопку Рассчитать, чтобы увидеть результаты.", elementId: "calculateBtn" },
        { text: "Это прогресс-бар и процентные показатели. Бар визуально отображает соотношение чистой Прибыли (синий) и Затрат на электроэнергию (серый). Ниже указаны их процентные доли от общего дневного Дохода.", elementId: "dailyMetricsContainer" }, // MODIFIED/COMBINED
        { text: "В таблице с Доходом и Прибылью вы можете переключать отображаемую валюту между долларами ($) и рублями (₽).", elementId: "resultsTable" },
        { text: "Здесь отображаются Окупаемость оборудования в месяцах и Годовой процент возврата инвестиций (ROI).", elementId: "paybackRoiContainer" }, // MODIFIED/COMBINED
        { title: "Обучение завершено!", text: "Поздравляем! Теперь вы знаете все основные функции калькулятора. Удачных расчетов!", elementId: null }
    ];
}


function startTutorialFlow() {
    currentTutorialStep = 0;
    tutorialModalOverlay.style.display = 'block';
    tutorialModal.style.display = 'block';
    document.body.classList.add('tutorial-active');
    Telegram.WebApp.expand(); // Expand the Web App view
    displayCurrentTutorialStep();
}

function removeHighlight() {
    if (highlightedElement) {
        highlightedElement.classList.remove('tutorial-highlight');
        highlightedElement.classList.remove('tutorial-text-white'); // Remove the white text class
        highlightedElement = null;
    }
    highlightedAncestors.forEach(ancestor => ancestor.classList.remove('tutorial-highlighted-ancestor'));
    highlightedAncestors = [];
    // Cleanup any stragglers, though should not be necessary with proper management
    document.querySelectorAll('.tutorial-highlight').forEach(el => el.classList.remove('tutorial-highlight'));
    document.querySelectorAll('.tutorial-highlighted-ancestor').forEach(el => el.classList.remove('tutorial-highlighted-ancestor'));
    document.querySelectorAll('.tutorial-text-white').forEach(el => el.classList.remove('tutorial-text-white')); // Ensure any lingering classes are removed
}


function displayCurrentTutorialStep() {
    removeHighlight(); // Clear previous highlight

    if (currentTutorialStep >= tutorialSteps.length) {
        completeTutorialProcess();
        return;
    }

    const step = tutorialSteps[currentTutorialStep];
    tutorialTitle.textContent = step.title || "Подсказка"; // Default title if not specified
    tutorialText.innerHTML = step.text; // Use innerHTML to allow <br> tags

    // Default modal position (centered)
    tutorialModal.style.top = '50%';
    tutorialModal.style.left = '50%';
    tutorialModal.style.transform = 'translate(-50%, -50%)';

    if (step.elementId) {
        const targetElement = document.getElementById(step.elementId);
        if (targetElement) {
            highlightedElement = targetElement;
            highlightedElement.classList.add('tutorial-highlight');

            // Specific elements that might need white text when their background is also highlighted or dark
             const elementsToChangeColor = [
                // "profitPercentageLabel", // These are now part of dailyMetricsContainer
                // "costPercentageLabel",
                // "paybackLabelContainer", // Part of paybackRoiContainer
                // "roiLabelContainer"
                // Add IDs here if direct children of highlighted element need text color change
            ];

            if (elementsToChangeColor.includes(step.elementId)) {
                highlightedElement.classList.add('tutorial-text-white');
            }


            // Make ancestors clickable
            let parent = targetElement.parentElement;
            while (parent && parent !== document.body) {
                parent.classList.add('tutorial-highlighted-ancestor');
                highlightedAncestors.push(parent);
                parent = parent.parentElement;
            }
            // Scroll to the element and position modal nearby
            targetElement.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });

            // Delay modal repositioning until scroll is likely complete
            setTimeout(() => {
                const targetRect = targetElement.getBoundingClientRect();
                const modalRect = tutorialModal.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;

                let modalTop = targetRect.bottom + 15; // Default below element
                let modalLeft = targetRect.left + (targetRect.width / 2) - (modalRect.width / 2); // Centered horizontally

                // Adjust if modal goes off-screen
                if (modalTop + modalRect.height > viewportHeight - 10) { // If too low, position above
                    modalTop = targetRect.top - modalRect.height - 15;
                }
                if (modalTop < 10) { // If too high (e.g., element at top, modal above goes off-screen)
                    modalTop = 10;
                }
                if (modalLeft + modalRect.width > viewportWidth - 10) { // If too far right
                    modalLeft = viewportWidth - modalRect.width - 10;
                }
                if (modalLeft < 10) { // If too far left
                    modalLeft = 10;
                }

                tutorialModal.style.top = `${modalTop}px`;
                tutorialModal.style.left = `${modalLeft}px`;
                tutorialModal.style.transform = 'translate(0, 0)'; // Reset transform if we manually set top/left
            }, 300); // Increased timeout slightly for smoother scroll then position

        } else {
            console.warn(`Элемент для обучения с ID "${step.elementId}" не найден.`);
            // Fallback to centered modal if element not found
            tutorialModal.style.top = '50%';
            tutorialModal.style.left = '50%';
            tutorialModal.style.transform = 'translate(-50%, -50%)';
        }
    } else {
        // For steps without an elementId (like the final step), center the modal
        tutorialModal.style.top = '50%';
        tutorialModal.style.left = '50%';
        tutorialModal.style.transform = 'translate(-50%, -50%)';
    }

    // Update button text for the last step
    if (currentTutorialStep === tutorialSteps.length - 1) {
        tutorialNextBtn.textContent = "Завершить";
    } else {
        tutorialNextBtn.textContent = "Далее";
    }
}


tutorialNextBtn.addEventListener('click', () => {
    currentTutorialStep++;
    displayCurrentTutorialStep();
});

tutorialSkipBtn.addEventListener('click', () => {
    completeTutorialProcess(true); // true indicates skipped
});

async function completeTutorialProcess(skipped = false) {
    tutorialModalOverlay.style.display = 'none';
    tutorialModal.style.display = 'none';
    document.body.classList.remove('tutorial-active');
    removeHighlight(); // Ensure any active highlight is removed
    console.log(skipped ? "Обучение пропущено." : "Обучение завершено.");

    if (!telegramUser || !telegramUser.id || !supabaseClient) {
        console.warn("Не удалось сохранить статус обучения: нет пользователя или Supabase клиента.");
        return;
    }
    try {
        const { data, error } = await supabaseClient
            .from('users')
            .upsert({ telegram_id: telegramUser.id.toString(), tutor: true, updated_at: new Date() }, { onConflict: 'telegram_id' })
            .select(); // Select to confirm
        if (error) {
            console.error("Ошибка сохранения статуса обучения в Supabase:", error);
        } else {
            console.log("Статус обучения успешно сохранен в Supabase:", data);
        }
    } catch (e) {
        console.error("Исключение при сохранении статуса обучения:", e);
    }
}
// --- КОНЕЦ БЛОКА ОБУЧЕНИЯ ---

// --- НАЧАЛО БЛОКА ФОРМАТИРОВАНИЯ СТОИМОСТИ ОБОРУДОВАНИЯ ---
function formatNumberWithSpaces(numberOrString) {
    const cleanedNumberStr = String(numberOrString).replace(/\s+/g, '').replace(/[^\d]/g, '');
    if (cleanedNumberStr === '') return '';
    return cleanedNumberStr.replace(/\B(?=(\d{3})+(?!\d))/g, " ");
}

function handleAsicCostInputFormatting(e) {
    const currentValue = e.target.value;
    const numericValue = currentValue.replace(/\s+/g, '').replace(/[^\d]/g, '');
    const formattedValue = formatNumberWithSpaces(numericValue);

    if (currentValue !== formattedValue) {
        e.target.value = formattedValue;
        // Place cursor at the end. This is the simplest, most robust way
        // to handle cursor after dynamic reformatting.
        e.target.setSelectionRange(formattedValue.length, formattedValue.length);
    }
}
// --- КОНЕЦ БЛОКА ФОРМАТИРОВАНИЯ СТОИМОСТИ ОБОРУДОВАНИЯ ---


let jsonData = [];
let currentAlgorithm = "SHA-256";
let dailyIncome = 0;
let dailyProfitValue = 0;
let dailyElectricityCostValue = 0;
let monthlyProfit = 0;
let yearlyProfit = 0;
let usdtPrice = 0;
let isUSD = true;
let currentModelVariants = [];

document.addEventListener("DOMContentLoaded", initAppAndTutorial);


async function fetchData() {
    console.log("Загрузка kursBTC.txt...");
    try {
        const response = await fetch("https://hamsauno.github.io/Miner/kursBTC.txt");
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const text = await response.text();
        const data = text.trim().split("\n");
        console.log("✅ Строки из kursBTC.txt:", data);
        if (data.length >= 9) {
            const values = {
                btcPrice: parseFloat(data[0]), usdtPrice: parseFloat(data[1]), profitPerTH: parseFloat(data[2]),
                ltcPrice: parseFloat(data[3]), dogePrice: parseFloat(data[4]), bellPrice: parseFloat(data[5]),
                profitPerLTC: parseFloat(data[6]), profitPerDOGE: parseFloat(data[7]), profitPerBELL: parseFloat(data[8]),
            };
            Object.entries(values).forEach(([key, val]) => {
                if (isNaN(val)) console.warn(`⚠️ Некорректное значение для ${key} из TXT:`, data[Object.keys(values).indexOf(key)]);
                const el = document.getElementById(key);
                if (el && !isNaN(val)) {
                    el.value = val.toFixed(key.startsWith("profit") ? 8 : 2);
                    if (key === "usdtPrice") usdtPrice = val;
                } else if (!el) console.warn(`⚠️ Элемент с ID ${key} не найден.`);
            });
            if (Object.values(values).some(isNaN)) console.warn("Внимание: Некоторые данные из kursBTC.txt не удалось прочитать корректно.");
            else console.log("📥 Значения из TXT успешно загружены.");
            if (usdtPrice > 0) console.log(`Курс USDT обновлен: ${usdtPrice}`); else console.warn("Курс USDT невалиден или не загружен.");

        } else console.warn("❗ Недостаточно строк в kursBTC.txt.");
    } catch (e) {
        console.error("❌ Критическая ошибка загрузки kursBTC.txt:", e);
        const calcBtn = document.getElementById('calculateBtn');
        if(calcBtn) calcBtn.disabled = true;
    }
}

async function fetchJsonData() {
    console.log(`Загрузка calc.json...`);
    try {
        const response = await fetch("https://hamsauno.github.io/Miner/json/calc.json");
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const data = await response.json();
        jsonData = data["Расчёты"] || [];
        console.log(`✅ Загружено ${jsonData.length} всего моделей.`);
        if (jsonData.length === 0) console.warn(`⚠️ Модели не найдены в calc.json`);
    } catch (e) {
        console.error(`❌ Ошибка загрузки или парсинга calc.json:`, e);
        jsonData = []; // Ensure jsonData is an empty array on error
        const manSelect = document.getElementById("manufacturerSelect");
        const modSelect = document.getElementById("asicModel");
        if (manSelect) manSelect.innerHTML = '<option>Ошибка загрузки</option>';
        if (modSelect) modSelect.innerHTML = '<option>Ошибка загрузки</option>';
    }
}


async function onAlgorithmChange() {
    const algorithmSelect = document.getElementById("algorithmSelect");
    if (!algorithmSelect) return;
    currentAlgorithm = algorithmSelect.value;
    console.log(`Алгоритм изменен на: ${currentAlgorithm}`);

    if (jsonData.length === 0) { // Fetch only if not already fetched
        await fetchJsonData();
    }

    const manufacturerSelect = document.getElementById("manufacturerSelect");
    if (!manufacturerSelect) return; // Should not happen if DOM is correct

    const modelsForCurrentAlgorithm = jsonData.filter(item => item["Алгоритм"] === currentAlgorithm);
    const uniqueManufacturers = [...new Set(modelsForCurrentAlgorithm.map(item => item["Производитель"]?.toLowerCase() || 'unknown'))]
                                .filter(m => m !== 'unknown').sort(); // Filter out 'unknown' and sort

    manufacturerSelect.innerHTML = ""; // Clear previous options
    if (uniqueManufacturers.length > 0) {
        uniqueManufacturers.forEach(manufacturer => {
            const opt = document.createElement("option");
            opt.value = manufacturer;
            opt.textContent = manufacturer.charAt(0).toUpperCase() + manufacturer.slice(1); // Capitalize
            manufacturerSelect.appendChild(opt);
        });
        manufacturerSelect.disabled = false;
        console.log(`Производители для ${currentAlgorithm} обновлены.`);
    } else {
        manufacturerSelect.innerHTML = '<option>Нет данных</option>';
        manufacturerSelect.disabled = true;
        console.warn(`Производители для ${currentAlgorithm} не найдены.`);
    }
    updateModelList(); // Update models based on the (newly) selected manufacturer or first one
}


function updateModelList() {
    const manufacturerSelect = document.getElementById("manufacturerSelect");
    const modelSelect = document.getElementById("asicModel");
    if (!manufacturerSelect || !modelSelect) return;

    const selectedManufacturer = manufacturerSelect.value?.toLowerCase(); // Ensure it's lowercase for comparison
    modelSelect.innerHTML = ""; // Clear previous model options

    // Filter models based on current algorithm AND selected manufacturer
    const modelsFiltered = jsonData.filter(item =>
        item["Алгоритм"] === currentAlgorithm &&
        item["Производитель"]?.toLowerCase() === selectedManufacturer
    );

    const uniqueModels = [...new Set(modelsFiltered.map(item => item["Модель"]))].sort(); // Get unique model names and sort

    if (uniqueModels.length > 0) {
        uniqueModels.forEach(modelName => {
            const opt = document.createElement("option");
            opt.value = modelName;
            opt.textContent = modelName;
            modelSelect.appendChild(opt);
        });
        modelSelect.disabled = false;
    } else {
        modelSelect.innerHTML = '<option>Нет моделей</option>';
        modelSelect.disabled = true;
    }
    updateAsicSpecs(); // Update specs based on the (newly) selected model or first one
}


function updateAsicSpecs() {
    const modelSelect = document.getElementById("asicModel");
    const asicCostInput = document.getElementById("asicCost");
    const hashrateContainer = document.getElementById("hashrateContainer"); // The main container for hashrate display/select
    const powerEl = document.getElementById("power");
    const powerUnitEl = document.getElementById("power_unit");

    // Clear previous dynamic content and values
    hashrateContainer.innerHTML = '<span id="hashrate"></span><span id="edprice"></span>'; // Reset to default spans
    document.getElementById("hashrate").textContent = '';
    document.getElementById("edprice").textContent = '';
    if (powerEl) powerEl.textContent = '';
    if (powerUnitEl) powerUnitEl.textContent = '';
    if (asicCostInput) {
      asicCostInput.value = '';
      asicCostInput.placeholder = 'Выберите модель';
    }
    currentModelVariants = []; // Reset variants

    const selectedModelName = modelSelect.value;

    // Check if a valid model is selected
    if (!selectedModelName || modelSelect.selectedOptions.length === 0 || modelSelect.selectedOptions[0].disabled || modelSelect.selectedOptions[0].textContent.startsWith("Нет")) {
        return; // No valid model selected, so keep fields blank or with placeholders
    }

    // Find all variants of the selected model for the current algorithm
    currentModelVariants = jsonData.filter(item =>
        item["Модель"] === selectedModelName &&
        item["Алгоритм"] === currentAlgorithm
    );

    // Sort variants, e.g., by hashrate (descending is often useful)
    currentModelVariants.sort((a, b) => parseFloat(b["Хешрейт"]) - parseFloat(a["Хешрейт"]));

    if (currentModelVariants.length > 0) {
        if (currentModelVariants.length === 1) {
            // Only one variant, display its specs directly
            const item = currentModelVariants[0];
            document.getElementById("hashrate").textContent = item["Хешрейт"] || '';
            document.getElementById("edprice").textContent = item["Ед. изм."] || '';
            populateSpecsForVariant(item);
        } else {
            // Multiple variants, create a select element within hashrateContainer
            let selectHTML = '<select id="hashrateSelect" class="bg-[#E2E2E2] w-full h-full border-none text-black text-sm focus:outline-none">';
            currentModelVariants.forEach((variant, index) => {
                selectHTML += `<option value="${index}">${variant["Хешрейт"]} ${variant["Ед. изм."]}</option>`;
            });
            selectHTML += '</select>';
            hashrateContainer.innerHTML = selectHTML; // Replace spans with select

            const hashrateSelectElement = document.getElementById("hashrateSelect");
            if (hashrateSelectElement) {
                 hashrateSelectElement.addEventListener('change', function() {
                    populateSpecsForVariant(currentModelVariants[this.value]);
                });
            }
            // Populate specs for the first (default selected) variant
            populateSpecsForVariant(currentModelVariants[0]);
        }
    } else {
        if (asicCostInput) asicCostInput.placeholder = 'Данные не найдены';
    }
}


function populateSpecsForVariant(item) {
    const powerEl = document.getElementById("power");
    const powerUnitEl = document.getElementById("power_unit");
    const asicCostInput = document.getElementById("asicCost");

    if (!item) { // Should not happen if called correctly, but good guard
        if (powerEl) powerEl.textContent = '';
        if (powerUnitEl) powerUnitEl.textContent = '';
        if (asicCostInput) {
            asicCostInput.value = '';
            asicCostInput.placeholder = 'Данные не найдены';
        }
        return;
    }

    const powerValue = parseFloat(item["Потребление"]);
    if (powerEl) powerEl.textContent = isNaN(powerValue) ? '' : Math.round(powerValue);
    if (powerUnitEl) powerUnitEl.textContent = isNaN(powerValue) ? '' : ' Вт';

    const itemPriceUSD = parseFloat(item["Цена"]);
    if (asicCostInput) {
        if (!isNaN(itemPriceUSD) && usdtPrice > 0) {
            const costInRub = Math.ceil((itemPriceUSD * usdtPrice) / 100) * 100; // Round to nearest 100 rub
            asicCostInput.value = formatNumberWithSpaces(costInRub); // Apply formatting
        } else {
            asicCostInput.value = ''; // Clear if no price or USDT rate
            asicCostInput.placeholder = (usdtPrice <= 0 && !isNaN(itemPriceUSD)) ? 'Курс USDT?' : 'Цена не найдена';
        }
    }
}

function showNotification() {
    const notification = document.getElementById('notification');
    if(notification) {
        notification.classList.remove('hidden');
        setTimeout(() => notification.classList.add('hidden'), 1000);
    }
}

function calculateProfit() {
    const elements = {
        usdtPriceInput: document.getElementById("usdtPrice"), powerEl: document.getElementById("power"),
        electricityCostInput: document.getElementById('electricityCost'), asicCostInput: document.getElementById("asicCost"),
        btcPriceInput: document.getElementById("btcPrice"), profitPerTHInput: document.getElementById("profitPerTH"),
        ltcPriceInput: document.getElementById("ltcPrice"), dogePriceInput: document.getElementById("dogePrice"),
        bellPriceInput: document.getElementById("bellPrice"), profitPerLTCInput: document.getElementById("profitPerLTC"),
        profitPerDOGEInput: document.getElementById("profitPerDOGE"), profitPerBELLInput: document.getElementById("profitPerBELL"),
        incomeEl: document.getElementById("income"), incomeRubEl: document.getElementById("income_rub"),
        profitEl: document.getElementById("profit"), profitRubEl: document.getElementById("profit_rub"),
        incomeMonthEl: document.getElementById("incomeMonth"), incomeMonthRubEl: document.getElementById("incomeMonth_rub"),
        incomeYearEl: document.getElementById("incomeYear"), incomeYearRubEl: document.getElementById("incomeYear_rub"),
        profitMonthEl: document.getElementById("profitMonth"), profitMonthRubEl: document.getElementById("profitMonth_rub"),
        profitYearEl: document.getElementById("profitYear"), profitYearRubEl: document.getElementById("profitYear_rub"),
        roiEl: document.getElementById("roi"), paybackEl: document.getElementById("payback"),
        profitBar: document.getElementById("dailyProfitBar"), electricityBar: document.getElementById("dailyElectricityCostBar"),
        profitPercentageLabel: document.getElementById("profitPercentageLabel"), costPercentageLabel: document.getElementById("costPercentageLabel")
    };
    if (Object.values(elements).some(el => !el)) { console.error("❌ Ошибка: Один из элементов для расчета не найден!"); return; }

    let actualHashrate, selectedVariantHashrateUnit = '';
    const hashrateSelect = document.getElementById("hashrateSelect"); // Check if the select exists (for multi-variant models)
    if (hashrateSelect && currentModelVariants.length > 0 && hashrateSelect.value !== "") {
        const selectedVariant = currentModelVariants[hashrateSelect.value];
        if (selectedVariant) {
            actualHashrate = parseFloat(selectedVariant["Хешрейт"]);
            selectedVariantHashrateUnit = selectedVariant["Ед. изм."];
        } else { console.error("❌ Ошибка: Выбранный вариант хешрейта не найден."); return; }
    } else { // Fallback to single variant display if select not present
        const hs = document.getElementById("hashrate");
        const edp = document.getElementById("edprice");
        if (hs) actualHashrate = parseFloat(hs.textContent); else { console.error("❌ Ошибка: Элемент хешрейта #hashrate не найден."); return; }
        if (edp) selectedVariantHashrateUnit = edp.textContent;
    }

    let calculationHashrate = actualHashrate; // This is the hashrate in the unit specified (TH, GH, MH)
    // Normalize SHA-256 hashrate to TH/s for calculation with profitPerTH
    if (currentAlgorithm === "SHA-256" && selectedVariantHashrateUnit) {
        const unitUpper = selectedVariantHashrateUnit.toUpperCase();
        if (unitUpper.includes("PH")) calculationHashrate *= 1000;       // PH/s to TH/s
        else if (unitUpper.includes("GH")) calculationHashrate /= 1000;  // GH/s to TH/s
        else if (unitUpper.includes("MH")) calculationHashrate /= 1000000; // MH/s to TH/s
        // Assuming TH/s requires no conversion if "TH" is present or unit is just "T"
    }
    // For Scrypt, the profitPerLTC/DOGE/BELL is usually per MH/s, so if hashrate is in GH/s, convert
    // This part depends on how profitPerLTC/DOGE/BELL are defined. Assuming they are per base unit of hashrate provided (e.g. MH/s for L7)
    // If Scrypt hashrates are consistently in MH/s in JSON, no conversion needed if profit rates are also per MH/s.
    // If JSON has GH/s for Scrypt, and profit rates are per MH/s, then multiply by 1000.
    // For now, assume Scrypt hashrate in JSON is the unit profit figures correspond to.

    const values = {
        currentUsdtPrice: parseFloat(elements.usdtPriceInput.value), hashrate: calculationHashrate,
        power: parseFloat(elements.powerEl.textContent), electricityCost: parseFloat(elements.electricityCostInput.value.replace(',', '.')),
        asicCost: parseFloat(elements.asicCostInput.value.replace(/\s+/g, '')) // Remove spaces for parsing
    };

    if (Object.values(values).slice(0,4).some(isNaN) || values.currentUsdtPrice <= 0 || values.hashrate <= 0) { // Check first 4 essential values
        console.error("❌ Ошибка: Некорректные базовые значения для расчета.", values);
        // Optionally alert user or display error message in UI
        return;
    }
     if (isNaN(values.asicCost)) { // Asic cost can be optional for some calculations but not for ROI/Payback
        console.warn("⚠️ Стоимость ASIC не указана или некорректна, ROI и окупаемость не будут рассчитаны.");
        // values.asicCost will be NaN here, calculations below handle it.
    }


    dailyIncome = 0;
    if (currentAlgorithm === "SHA-256") {
        const btcP = parseFloat(elements.btcPriceInput.value), pPTH = parseFloat(elements.profitPerTHInput.value);
        if (!isNaN(btcP) && !isNaN(pPTH)) dailyIncome = values.hashrate * pPTH * btcP; else { console.error("❌ SHA-256 calc error: btcPrice or profitPerTH is NaN"); return;}
    } else if (currentAlgorithm === "Scrypt") {
        const ltcP = parseFloat(elements.ltcPriceInput.value), dogeP = parseFloat(elements.dogePriceInput.value), bellP = parseFloat(elements.bellPriceInput.value);
        const pPLTC = parseFloat(elements.profitPerLTCInput.value), pPDOGE = parseFloat(elements.profitPerDOGEInput.value), pPBELL = parseFloat(elements.profitPerBELLInput.value);
        if (![ltcP, dogeP, bellP, pPLTC, pPDOGE, pPBELL].some(isNaN)) {
            // Assuming 'values.hashrate' is in the correct unit for these profit factors (e.g., MH/s)
            dailyIncome = values.hashrate * (pPLTC * ltcP + pPDOGE * dogeP + pPBELL * bellP);
        } else { console.error("❌ Scrypt calc error: one of the prices or profit factors is NaN"); return;}
    }

    dailyElectricityCostValue = (values.power / 1000) * values.electricityCost * 24 / values.currentUsdtPrice; // Cost in USD
    window.dailyProfitValue = dailyIncome - dailyElectricityCostValue; // Profit in USD
    monthlyProfit = window.dailyProfitValue * 30.5; yearlyProfit = window.dailyProfitValue * 365;

    let roi = 0, payback = Infinity; // Default values
    if (!isNaN(values.asicCost) && values.asicCost > 0) {
        const asicCostInUSD = values.asicCost / values.currentUsdtPrice;
        if (asicCostInUSD > 0) { // Ensure no division by zero or negative cost
            if (yearlyProfit) roi = (yearlyProfit / asicCostInUSD) * 100;
            if (window.dailyProfitValue > 0) payback = (asicCostInUSD / window.dailyProfitValue) / 30.5; // Payback in months
        }
    }


    updateTableValues(); updateProgressBarAndLabels(elements);
    elements.roiEl.innerText = isFinite(roi) && roi !== 0 ? roi.toFixed(1) : "—";
    elements.paybackEl.innerText = isFinite(payback) ? payback.toFixed(1) : "—";
    showNotification();
}


function formatCurrency(value, currency = "$", fractionDigits = 2) {
    if (isNaN(value) || !isFinite(value)) return currency === "$" ? "$ --.--" : "--.-- ₽";
    return currency + (Math.round(value * Math.pow(10, fractionDigits)) / Math.pow(10, fractionDigits))
        .toLocaleString('ru-RU', { minimumFractionDigits: fractionDigits, maximumFractionDigits: fractionDigits });
}
function formatCurrencyRub(value, fractionDigits = 0) { // Rubles typically don't show kopecks in this context
    if (isNaN(value) || !isFinite(value) || isNaN(usdtPrice) || usdtPrice <= 0) return "-- ₽";
    return (Math.round((value * usdtPrice) * Math.pow(10, fractionDigits)) / Math.pow(10, fractionDigits))
        .toLocaleString('ru-RU', { maximumFractionDigits: fractionDigits }) + " ₽";
}


function updateTableValues() {
    const ids = ["income", "incomeMonth", "incomeYear", "profit", "profitMonth", "profitYear"];
    ids.forEach(id => {
        const usdEl = document.getElementById(id), rubEl = document.getElementById(`${id}_rub`);
        if (usdEl && rubEl) {
            let valUSD = 0;
            if (id.startsWith("incomeMonth")) valUSD = dailyIncome * 30.5;
            else if (id.startsWith("incomeYear")) valUSD = dailyIncome * 365;
            else if (id.startsWith("income")) valUSD = dailyIncome;
            else if (id.startsWith("profitMonth")) valUSD = monthlyProfit;
            else if (id.startsWith("profitYear")) valUSD = yearlyProfit;
            else if (id.startsWith("profit")) valUSD = window.dailyProfitValue;

            usdEl.innerText = formatCurrency(valUSD);
            rubEl.innerText = formatCurrencyRub(valUSD);
            usdEl.classList.toggle("hidden", !isUSD);
            rubEl.classList.toggle("hidden", isUSD);
        }
    });
}

function setCurrency(setToUSD) {
    if (isUSD === setToUSD) return; // No change needed
    isUSD = setToUSD;
    const usdBtn = document.getElementById('currencyUSD'), rubBtn = document.getElementById('currencyRUB');
    if (usdBtn && rubBtn) {
        usdBtn.classList.toggle('active', isUSD);
        usdBtn.classList.toggle('inactive', !isUSD);
        rubBtn.classList.toggle('active', !isUSD);
        rubBtn.classList.toggle('inactive', isUSD);
        updateTableValues(); // Refresh table with new currency
    }
}

function updateProgressBarAndLabels(elements) {
    const { profitBar, electricityBar, profitPercentageLabel, costPercentageLabel } = elements;
    let profitPerc = 0, electricityPerc = 0;

    if (dailyIncome > 0 && isFinite(dailyIncome) && isFinite(dailyElectricityCostValue)) {
        // Calculate profit percentage relative to gross income
        profitPerc = (window.dailyProfitValue / dailyIncome) * 100;
        // Calculate electricity cost percentage relative to gross income
        electricityPerc = (dailyElectricityCostValue / dailyIncome) * 100;

        if (window.dailyProfitValue <= 0) { // If not profitable or losing money
            profitPerc = 0; // No profit part in the bar
            // Electricity cost might be > income. Cap at 100% for visualization or show actual.
            // If income is positive but less than cost, cost bar takes 100%.
            // If income is zero or negative, visualization is tricky. Let's assume income is > 0 for this bar.
            electricityPerc = Math.min(100, electricityPerc); // Cap at 100% for bar display
        } else { // Profitable
             profitPerc = Math.max(0, Math.min(100, profitPerc)); // Clamp between 0 and 100
             electricityPerc = Math.max(0, Math.min(100 - profitPerc, electricityPerc)); // Clamp and ensure total <= 100
        }
    } else if (dailyIncome <= 0 && dailyElectricityCostValue > 0) { // Negative or zero income, but costs exist
        profitPerc = 0;
        electricityPerc = 100; // Show costs consuming everything
    }


    profitBar.style.width = `${profitPerc.toFixed(1)}%`;
    electricityBar.style.width = `${electricityPerc.toFixed(1)}%`;
    electricityBar.style.left = `${profitPerc.toFixed(1)}%`;

    profitPercentageLabel.textContent = `Прибыль: ${profitPerc.toFixed(1)}%`;
    costPercentageLabel.textContent = `Затраты: ${electricityPerc.toFixed(1)}%`;
}


// Event Listeners
const algSel = document.getElementById("algorithmSelect"),
      manSel = document.getElementById("manufacturerSelect"),
      modSel = document.getElementById("asicModel"),
      calcBtn = document.getElementById("calculateBtn"),
      currUSD = document.getElementById('currencyUSD'),
      currRUB = document.getElementById('currencyRUB');
      // asicCostInput listener is added in initAppAndTutorial

if (algSel) algSel.addEventListener("change", onAlgorithmChange);
if (manSel) manSel.addEventListener("change", updateModelList);
if (modSel) modSel.addEventListener("change", updateAsicSpecs);
if (calcBtn) calcBtn.addEventListener("click", calculateProfit);
if (currUSD) currUSD.addEventListener('click', () => setCurrency(true));
if (currRUB) currRUB.addEventListener('click', () => setCurrency(false));

</script>
</body>
</html>
